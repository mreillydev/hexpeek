// Copyright 2025 Michael Reilly (mreilly@mreilly.dev).
// 
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. Neither the names of the copyright holders nor the names of the
//    contributors may be used to endorse or promote products derived from
//    this software without specific prior written permission.
// 
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
// PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDERS
// OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
// EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
// OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
// WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
// OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
// ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

// WARNING: THIS CODE IS FOR TESTING PURPOSES ONLY.

// usage: [-d | -h[len]]
//   Print pseudorandomly generated number as decimal/hex to stdout
// usage: [-d | -h[len]] <min> <max>
//   Print pseudorandomly generated number in domain [min, max]
// usage: -f <crtfile> <length>
//   Create file of length pseudorandomly generated bytes
// usage: -f <crtfile> <min> <max>
//   As above, but pseudorandomly pick length in [min, max]
// usage: -x <major> <cmdcnt> <f0len> <f1len>
//   Print a string of pseudorandomly generated hexpeek write commands
// usage: -p
//   Print out the seed to be used for this run
// Additionally, the optional argument [-s seedfile] is recognized by all
//   command forms and can be used to specify a seed to srand(). The new
//   seed state will be written to seedfile at the run end.
// Numeric args may be any base recognized by strtoumax( , , 0)

#include <stdio.h>
#include <stdlib.h>
#include <stdarg.h>
#include <stdint.h>
#include <stdbool.h>
#include <inttypes.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <limits.h>
#include <fcntl.h>
#include <unistd.h>
#include <string.h>
#include <time.h>
#include <errno.h>
#include <assert.h>

#define BUFSZ 0x10000

unsigned int Seed = 0;

void randBuf(void *buf, size_t len)
{
    for(size_t ix = 0; ix < len; ix++)
    {
        int result = rand_r(&Seed);
        ((uint8_t*)buf)[ix] = 0;
        for(int part = 0; part < sizeof result; part++)
            ((uint8_t*)buf)[ix] ^= ((uint8_t*)&result)[part];
    }
}

void writeFile(int fd, uintmax_t size)
{
    size_t len = BUFSZ;
    uint8_t buffer[BUFSZ];
    for(uintmax_t index = 0; index < size; index += len)
    {
        if(size - index < BUFSZ)
            len = size - index;
        randBuf(buffer, len);
        assert(write(fd, buffer, len) == len);
    }
}

uintmax_t randUmax()
{
    uintmax_t result = 0;
    randBuf(&result, sizeof result);
    return result;
}

uintmax_t randRange(uintmax_t rmin, uintmax_t rmax)
{
    uintmax_t result = randUmax();
    result %= (rmax - rmin + 1);
    result += rmin;
    return result;
}

int randBit()
{
    unsigned int result = 0;
    randBuf(&result, sizeof result);
    return (int)(result % 2);
}

void randByteString(uintmax_t length)
{
    assert(length > 0);
    uint8_t buf[length];
    randBuf(buf, sizeof buf);
    for(uintmax_t ix = 0; ix < length; ix++)
        printf("%02X", buf[ix]);
}

// also defined in randtests
    #define MajorMin     1
    #define MajorMax     5
    #define MajorAny     9

    #define MajorReplace 1
    #define MajorInsert  2
    #define MajorAppend  3
    #define MajorHole    4
    #define MajorKill    5


void gencmds(uintmax_t major, uintmax_t cmdcnt,
             uintmax_t f0len, uintmax_t f1len)
{
    const uintmax_t litmax = 6000;
    const uintmax_t holemax = 9000;

    uintmax_t type = major;
    for(uintmax_t cmdix = 0; cmdix < cmdcnt; cmdix++)
    {
        char op = '\0';
        bool illiteral = false;
        uintmax_t dloc = 0, sloc = 0, datalen = 0, adjlen = 0;

        // File picker
        int srcf = 0, dstf = 0;
        if(f1len > 0)
        {
            srcf = randBit();
            dstf = randBit();
        }
        uintmax_t fSlen =(srcf ? f1len : f0len), fDlen =(dstf ? f1len : f0len);

        // Empty file
        if(fSlen < 1 || fDlen < 1)
        {
            op = 'i';
            datalen = randRange(1, litmax);
        }
        // General command generator
        else
        {
            // Randomly select type
            if(major == MajorAny)
                type = randRange(MajorMin, MajorMax);

            // Kill operation
            if(type == MajorKill)
            {
                op = 'k';
                adjlen = randRange(1, fDlen);
                fDlen -= adjlen;
                dloc = randRange(0, fDlen);
            }
            // All other operations
            else
            {
                // Literal or address data source
                if(randBit() == 1)
                {
                    datalen = randRange(1, litmax);
                }
                else
                {
                    illiteral = true;
                    datalen = randRange(1, fSlen);
                    sloc = randRange(0, fSlen - datalen);
                }

                // Repeated or unrepeated write
                adjlen = datalen;
                if(randBit() == 1)
                    adjlen = randRange(datalen, 4 * datalen);

                // Ascertain location
                switch(type)
                {
                case MajorReplace:
                case MajorInsert:
                    dloc = randRange(0, fDlen - 1);
                    break;
                case MajorAppend:
                    dloc = fDlen;
                    break;
                case MajorHole:
                    dloc = randRange(fDlen + 1, fDlen + holemax);
                    break;
                default:
                    exit(30);
                }

                // Ascertain command and update destination file length
                switch(type)
                {
                case MajorReplace:
                    op = 'r';
                    uintmax_t replace_end = dloc + adjlen;
                    if(replace_end > fDlen)
                        fDlen = replace_end;
                    break;
                default:
                    op = 'i';
                    if(type == MajorHole)
                        fDlen = dloc;
                    fDlen += adjlen;
                    break;
                }
            }
        }

        assert(op != '\0');

        // Append generated command
        printf("$%d@%jX", dstf, dloc);
        if(datalen != adjlen)
            printf(",%jX", adjlen);
        printf("%c", op);
        if(illiteral)
            printf("$%d@%jX,%jX", srcf, sloc, datalen);
        else if(datalen)
            randByteString(datalen);
        printf(";");

        // Update destination file length
        switch(dstf)
        {
        case 0: f0len = fDlen; break;
        case 1: f1len = fDlen; break;
        }
    }
}

int main(int argc, char **argv)
{
    bool seedset = false;
    int seedfd = -1, wrfd = -1;
    int print_hex = 1, print_minlen = 1, range_given = 0;
    uintmax_t rmin = 0, rmax = 0, result = 0;
    char buf[64], *endptr = NULL;

    if(argc >= 2 && strcmp(argv[1], "-s") == 0)
    {
        assert(argc >= 3);
        seedfd = open(argv[2], O_RDWR);
        assert(seedfd >= 0);
        memset(buf, '\0', sizeof buf);
        ssize_t rdlen = read(seedfd, buf, sizeof buf);
        assert(rdlen >= 0);
        if(rdlen > 0)
        {
            assert(buf[sizeof buf - 1] == '\0');
            unsigned long int tmpul = strtoul(buf, &endptr, 16);
            assert(endptr != buf);
            if(*endptr == '\n')
            {
                *endptr = '\0';
                endptr++;
            }
            assert(*endptr == '\0');
            assert(tmpul < UINT_MAX);
            Seed = (unsigned int)tmpul;
            seedset = true;
        }
        argc--;
        argv++;
        argc--;
        argv++;
    }

    if( ! seedset)
    {
        int randfd = open("/dev/urandom", O_RDONLY);
        if(randfd >= 0)
        {
            assert(read(randfd, &Seed, sizeof Seed) == sizeof Seed);
            close(randfd);
        }
        else
        {
            void *randp = malloc(16);
            Seed = time(NULL) ^ (unsigned int)randp;
            free(randp);
        }
    }

    srand(Seed);

    if(argc >= 2)
    {
        if(strcmp(argv[1], "-p") == 0)
        {
            printf("%X\n", Seed);
            goto end;
        }
        if(strcmp(argv[1], "-x") == 0)
        {
            assert(argc == 6);
            uintmax_t major = strtoumax(argv[2], &endptr, 0);
            assert(*endptr == '\0');
            uintmax_t cmdcnt = strtoumax(argv[3], &endptr, 0);
            assert(*endptr == '\0');
            uintmax_t f0len = strtoumax(argv[4], &endptr, 0);
            assert(*endptr == '\0');
            uintmax_t f1len = strtoumax(argv[5], &endptr, 0);
            assert(*endptr == '\0');
            gencmds(major, cmdcnt, f0len, f1len);
            goto end;
        }
        else if(strncmp(argv[1], "-h", 2) == 0)
        {
            argv[1] += 2;
            print_hex = 1;
            if(*argv[1] != '\0')
            {
                print_minlen = atoi(argv[1]);
                assert(print_minlen >= 1);
            }
            argc--;
            argv++;
        }
        else if(strcmp(argv[1], "-d") == 0)
        {
            print_hex = 0;
            argc--;
            argv++;
        }
        else if(strcmp(argv[1], "-f") == 0)
        {
            argc--;
            argv++;
            assert(argc >= 2);
            wrfd = open(argv[1], O_WRONLY|O_CREAT|O_TRUNC, S_IWUSR|S_IRUSR);
            assert(wrfd >= 0);
            argc--;
            argv++;
            assert(argc >= 2);
        }

        if(argc >= 2)
        {
            range_given = 1;
            rmin = strtoumax(argv[1], &endptr, 0);
            assert(*endptr == '\0');
            if(wrfd < 0)
                assert(argc >= 3);
            if(argc >= 3)
            {
                assert(argc == 3);
                rmax = strtoumax(argv[2], &endptr, 0);
                assert(*endptr == '\0');
                assert(rmax >= rmin);
            }
            else
            {
                rmax = rmin;
            }
        }
    }

    if(range_given)
        result = randRange(rmin, rmax);
    else
        result = randUmax();
    if(wrfd < 0)
    {
        if(print_hex)
            printf("%0*jX\n", print_minlen, result);
        else
            printf("%ju\n", result);
    }
    else
    {
        writeFile(wrfd, result);
    }

end:
    if(seedfd >= 0)
    {
        assert(ftruncate(seedfd, 0) == 0);
        memset(buf, '\0', sizeof buf);
        assert(snprintf(buf, sizeof buf - 1, "%X", Seed) > 0);
        assert(lseek(seedfd, 0, SEEK_SET) == 0);
        assert(write(seedfd, buf, strlen(buf)) == strlen(buf));
        close(seedfd);
    }
    if(wrfd >= 0)
        close(wrfd);
    exit(0);
}
